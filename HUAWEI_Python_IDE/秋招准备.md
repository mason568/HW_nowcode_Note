# ç¬”è¯•é¢˜ç›®
è¿™ä¸ªæ˜¯æˆ‘ä»¬æœºè€ƒçš„ç»éªŒå’Œç»ƒä¹ é¢˜ç½‘ç«™

å¸¸è€ƒçŸ¥è¯†ç‚¹ï¼š
- åŸºæœ¬æ“ä½œï¼šè¾“å…¥è¾“å‡ºå¤„ç†ï¼ˆé‡ç‚¹ï¼‰ï¼Œå­—ç¬¦ä¸²æ“ä½œä¸ASCiiç ï¼ˆé‡ç‚¹ï¼‰
- æ•°æ®ç»“æ„ï¼šä¸€ç»´æ•°ç»„ï¼Œæ ˆï¼Œé˜Ÿåˆ—
- ç¼–ç¨‹æ€æƒ³ï¼šæš´åŠ›æ³•ï¼ˆé‡ç‚¹ï¼‰ï¼Œé€’å½’
- ç®—æ³•ï¼šæ’åˆ—ç»„åˆï¼ˆé‡ç‚¹ï¼‰ï¼Œå¿«é€Ÿæ’åºï¼ˆé‡ç‚¹ï¼‰ï¼ŒäºŒåˆ†æŸ¥æ‰¾ï¼Œä½è¿ç®—ï¼Œæ»‘åŠ¨çª—å£ï¼Œæ·±åº¦ä¼˜å…ˆæœç´¢ï¼ˆè¿›é˜¶ï¼‰ï¼Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆè¿›é˜¶ï¼‰ï¼Œæœç´¢å›æº¯ï¼ˆè¿›é˜¶ï¼‰

ç™»å½•ç‰›å®¢ç½‘åä¸ºæœºè¯•ä¸“æ ç»ƒä¹ å¹¶ç†Ÿæ‚‰æœºè¯•ç¯å¢ƒï¼šhttps://www.nowcoder.com/ta/huawei
# æœºè€ƒè¾…å¯¼
1. éœ€è¦å¼€æ‘„åƒå¤´ï¼Œä¸èƒ½è®¿é—®å…¶ä»–ç½‘é¡µæˆ–æŸ¥æ‰¾èµ„æºï¼Œå¯ä»¥åœ¨æœ¬åœ°IDEè°ƒè¯•å¥½åæ‹·è´åˆ°ç‰›å®¢ç½‘ä¸Šå†è°ƒè¯•
2. å¤šåˆ·ä¸€ä¸‹å„ç§ç±»å‹ç®—æ³•é¢˜ï¼Œéš¾åº¦ä¸­ç­‰åŠä»¥ä¸Šï¼Œåœ¨ç‰›å®¢æœ‰æˆ–åŠ›æ‰£ä¸Šåˆ·éƒ½å¯ä»¥
3. ç†Ÿæ‚‰ç‰›å®¢ç½‘è€ƒè¯•ç¯å¢ƒï¼Œå’Œæœ¬åœ°IDEï¼ŒåŠ›æ‰£æœ‰å·®å¼‚
4. ACMæ¨¡å¼ï¼Œéœ€è¦è§£å†³è¾“å…¥è¾“å‡º
5. ä¸€å®šä¸è¦æ­»ç£•æŸä¸€é¢˜ï¼Œä¸‰é¢˜å¾—åˆ†åŠ èµ·æ¥è¾¾åˆ°åŠæ ¼åˆ†å³å¯

# é€ä¸ªå‡»ç ´
## ç‰›å®¢ç½‘ç¯å¢ƒcheck
è¾“å…¥è¾“å‡ºå¤„ç†
1. æ ¸å¿ƒä»£ç æ¨¡å¼å¤„ç†
ä¸éœ€è¦å¤„ç†ä»»ä½•è¾“å…¥è¾“å‡ºï¼Œç›´æ¥è¿”å›å€¼å³å¯ã€‚
2. ACM æ¨¡å¼
ä½ çš„ä»£ç éœ€è¦å¤„ç†è¾“å…¥è¾“å‡ºï¼Œè¯·ä½¿ç”¨å¦‚ä¸‹æ ·ä¾‹ä»£ç è¯»å–è¾“å…¥å’Œæ‰“å°è¾“å‡ºï¼š


```
#include <iostream>
using namespace std;

int main() {
    int a, b;
    while (cin >> a >> b) { // æ³¨æ„ while å¤„ç†å¤šä¸ª case ã€‚ è¿™ä¸ªwhileä»¥åç”¨èµ·æ¥
        cout << a + b << endl;
    }
}
// 64 ä½è¾“å‡ºè¯·ç”¨ printf("%lld")
```

> åä¸ºæœºè¯•é¢˜ç›®ï¼šhttps://www.nowcoder.com/ta/huawei

> pythonè§£æ³•è¿‡ç›®ï¼šhttps://pycoder.blog.csdn.net/article/details/124648380

## åˆ·é¢˜
loading...

## æ€»ç»“

### æ•°æ®ç»“æ„
1. setå’Œmapçš„keyæ˜¯æœ‰åºçš„ unorder_setå’Œunorder_mapæ— åºï¼Œéœ€è¦ä¸åŒçš„å¤´æ–‡ä»¶ï¼Œå¦å¤–ï¼Œmultimapå’Œmultisetçš„keyå…è®¸é‡å¤ï¼Œ keyæœ‰åº
> å‚è€ƒï¼šhttps://www.cnblogs.com/PiaYie/p/15877059.html

2. stringå¸¸ç”¨æ–¹æ³•
> https://blog.csdn.net/qq_37954088/article/details/82286530

3. [åœ¨c++ä¸­è°¨æ…ç”¨int](https://zhuanlan.zhihu.com/p/272570386#:~:text=%E8%AD%A6%E5%91%8A%20C26451%20%E7%AE%97%E6%9C%AF%E6%BA%A2%E5%87%BA%3A%20%E4%BD%BF%E7%94%A8%204%20%E5%AD%97%E8%8A%82%E5%80%BC%E4%B8%8A%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6%20%2B,%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86%E7%BB%93%E6%9E%9C%E8%BD%AC%E6%8D%A2%E5%88%B0%208%20%E5%AD%97%E8%8A%82%E5%80%BC%E3%80%82%20%E5%9C%A8%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%20%2B%20%E4%B9%8B%E5%89%8D%E5%B0%86%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AE%BD%E7%B1%BB%E5%9E%8B%E5%8F%AF%E9%81%BF%E5%85%8D%E6%BA%A2%E5%87%BA%20%28io.2%29%E3%80%82%20%E8%BF%99%E6%98%AF64%E4%BD%8D%E5%92%8C32%E4%BD%8D%E6%95%B4%E5%9E%8B%E5%AE%BD%E5%BA%A6%E4%B8%8D%E5%AF%B9%E9%BD%90%E7%9A%84%E8%AD%A6%E5%91%8A%E3%80%82)

> è¿™ä¸ªæ•´å‹å˜é‡ä¼šå‚ä¸åˆ°åœ°å€è¿ç®—å—ï¼Ÿ(å¯¹äºæ•´å‹å˜é‡è¿™éå¸¸å¸¸è§ï¼Œä¾‹å¦‚ç”¨ä½œæ•°ç»„ä»¥åŠstlçš„ç´¢å¼•)ï¼Œå¦‚æœæ˜¯ï¼Œé‚£ä¹ˆä¸è¦ç”¨intäº†ã€‚
> 
> åœ¨ç´¢å¼•è®¿é—®ã€æŒ‡é’ˆåœ°å€ç›¸å…³çš„è¿ç®—ä¸Šï¼Œä½¿ç”¨ptrdiff_tå’Œunsigned_intï¼Œåº”å½“æ˜¯è§„èŒƒçš„C++çš„ç»Ÿä¸€æ ‡å‡†ã€‚å¦åˆ™æ··ç”¨çš„è¯ï¼Œå¿…ç„¶ä¼šå‡ºç°å¤§ç‰‡çš„ç¼–è¯‘å™¨è­¦å‘Šï¼Œå¹¶ä¸”é™ä½ç¨‹åºæ•ˆç‡ã€‚

4. ä¼˜å…ˆé˜Ÿåˆ— å¤§å°å † priority_queue

å‚è€ƒå¤§ä½¬åšå®¢ï¼šhttps://www.cnblogs.com/huashanqingzhu/p/11040390.html
åŸºæœ¬ç”¨æ³•ï¼š
```
#include <iostream>
#include <algorithm>
#include<time.h>
#include<vector>
#include<queue>
#include"assert.h"
using namespace std;

//é‡å†™è¿ç®—ç¬¦>
//æ–¹æ³•1
class tmp1 //è¿ç®—ç¬¦é‡è½½<
{
public:
	int x;
	tmp1(int a) { x = a; }
	bool operator<(const tmp1& a) const //é»˜è®¤å·¦è¾¹æ˜¯thisæŒ‡é’ˆ
	{
		return x < a.x; //å¤§é¡¶å †
	}
};

struct cmp2 {
	bool operator() (tmp1 lhs, tmp1 rhs) {
		return lhs.x > rhs.x;
	}

};


//é‡å†™æ¯”è¾ƒå‡½æ•° 
struct cmp {
	bool operator() (int lhs, int rhs) {
		return lhs > rhs;
	}

};



//priority_queue
int main() {
	int n, k, t;
	while (cin >> n >> k) {
		vector<int> nums;
		priority_queue<int, vector<int>, cmp> min_queue;
		priority_queue<tmp1, vector<tmp1>, cmp2> tmp1_min_deque;
		for (int i = 0; i < n; i++) {
			cin >> t;
			nums.push_back(t);
			min_queue.push(t);
			tmp1_min_deque.push(t);
		}
		cout << "numsä¸­çš„å‰kä¸ªå€¼: ";
		int t = k;
		for (int i = 0; i < k; i++) {
			if (i < n) cout << nums[i] << " ";
		}
		cout << endl;
		cout << "min_queueä¸­çš„å‰kä¸ªå€¼: ";
		while (t-- && t <= min_queue.size()) {
			cout << min_queue.top() << " ";
			min_queue.pop();
		}
		cout << endl;
		cout << "tmp1_min_dequeä¸­çš„å‰kä¸ªå€¼: ";
		t = k;
		while (t-- && t <= tmp1_min_deque.size()) {
			cout << tmp1_min_deque.top().x << " ";
			tmp1_min_deque.pop();
		}
		cout << endl;
	}
	//å¯¹äºåŸºç¡€ç±»å‹ é»˜è®¤æ˜¯å¤§é¡¶å † STLé‡Œé¢é»˜è®¤ç”¨çš„æ˜¯vector 
	priority_queue<int> a;
	priority_queue<int,vector<int>,greater<int> > b; //å°é¡¶å †è¿™æ ·å†™

	//å‡åºé˜Ÿåˆ—ï¼Œå°é¡¶å †
	priority_queue <int, vector<int>, greater<int> > q; //æ³¨æ„> >æ‹¬å·ä¸­é—´çš„ç©ºæ ¼ï¼Œæ²¡æœ‰çš„è¯ç¼–è¯‘å™¨å¯èƒ½ä¼šè®¤ä¸ºæ˜¯å³ç§»è¿ç®—ç¬¦
	//é™åºé˜Ÿåˆ—ï¼Œå¤§é¡¶å † é»˜è®¤
	priority_queue <int, vector<int>, less<int> > p;
	//å…¶ä¸­ï¼Œgreaterå’Œlessæ˜¯stdå®ç°çš„ä¸¤ä¸ªä»¿å‡½æ•°ï¼ˆå°±æ˜¯ä½¿ä¸€ä¸ªç±»çš„ä½¿ç”¨çœ‹ä¸Šå»åƒä¸€ä¸ªå‡½æ•°ã€‚å…¶å®ç°å°±æ˜¯ç±»ä¸­å®ç°ä¸€ä¸ªoperator()ï¼Œè¿™ä¸ªç±»å°±æœ‰äº†ç±»ä¼¼å‡½æ•°çš„è¡Œä¸ºï¼Œå°±æ˜¯ä¸€ä¸ªä»¿å‡½æ•°ç±»äº†

	//è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°å¦‚ä¸Šé¢ä¾‹å­
	//é‡å†™æ¯”è¾ƒå‡½æ•°
	priority_queue<int, vector<int>, cmp> min_queue;
	//å¯¹ç±»çš„æ¯”è¾ƒ
	priority_queue<tmp1, vector<tmp1>, cmp2> tmp1_min_deque;
	return 0;

}


```

#### ä¸€äº›æ³¨æ„çš„ç‚¹
1. intç±»å‹è½¬æ¢æ¥åšæµ®ç‚¹æ•°çš„å››èˆäº”å…¥
```
int main() {
	float a;

	while (cin >> a) {
		if (a > 0) {
			cout << int(a + 0.5) << endl;
		}
	}

	return 0;
}
```

### è¾“å…¥è¾“å‡ºå¤„ç†
##### è¾“å…¥åŸç†

ç¨‹åºçš„è¾“å…¥éƒ½æœ‰ä¸€ä¸ªç¼“å†²åŒºï¼Œå³è¾“å…¥ç¼“å†²åŒºã€‚ä¸€æ¬¡è¾“å…¥è¿‡ç¨‹æ˜¯è¿™æ ·çš„ï¼Œå½“ä¸€æ¬¡é”®ç›˜è¾“å…¥ç»“æŸæ—¶ä¼šå°†è¾“å…¥çš„æ•°æ®å­˜å…¥è¾“å…¥ç¼“å†²åŒºï¼Œè€Œcinå¯¹è±¡ç›´æ¥ä»è¾“å…¥ç¼“å†²åŒºä¸­å–æ•°æ®ã€‚æ­£å› ä¸ºcinå¯¹è±¡æ˜¯ç›´æ¥ä»ç¼“å†²åŒºå–æ•°æ®çš„ï¼Œæ‰€ä»¥æœ‰æ—¶å€™å½“ç¼“å†²åŒºä¸­æœ‰æ®‹ç•™æ•°æ®æ—¶ï¼Œcinå¯¹è±¡ä¼šç›´æ¥å–å¾—è¿™äº›æ®‹ç•™æ•°æ®è€Œä¸ä¼šè¯·æ±‚é”®ç›˜è¾“å…¥

#### cinçš„è¯´æ˜ 
> å‚è€ƒ https://blog.csdn.net/selina8921/article/details/79067941
- è¯¥æ“ä½œç¬¦æ˜¯æ ¹æ®åé¢å˜é‡çš„ç±»å‹è¯»å–æ•°æ®ã€‚
- è¾“å…¥ç»“æŸæ¡ä»¶ ï¼šé‡åˆ°Enterã€Spaceã€Tabé”®ã€‚
- å½“cin>>ä»ç¼“å†²åŒºä¸­è¯»å–æ•°æ®æ—¶ï¼Œè‹¥ç¼“å†²åŒºä¸­ç¬¬ä¸€ä¸ªå­—ç¬¦æ˜¯ç©ºæ ¼ã€tabæˆ–æ¢è¡Œè¿™äº›åˆ†éš”ç¬¦æ—¶ï¼Œcin>>ä¼šå°†å…¶å¿½ç•¥å¹¶æ¸…é™¤ï¼Œç»§ç»­è¯»å–ä¸‹ä¸€ä¸ªå­—ç¬¦ï¼Œè‹¥ç¼“å†²åŒºä¸ºç©ºï¼Œåˆ™ç»§ç»­ç­‰å¾…ã€‚ä½†æ˜¯å¦‚æœè¯»å–æˆåŠŸï¼Œå­—ç¬¦åé¢çš„åˆ†éš”ç¬¦æ˜¯æ®‹ç•™åœ¨ç¼“å†²åŒºçš„ï¼Œcin>>ä¸åšå¤„ç†ã€‚

#### coutçš„è¯´æ˜
> è¾“å…¥ä¸€ä¸ªå­—ç¬¦ä¸²ä¸å¸¦ç©ºæ ¼ å’Œä¸€ä¸ªå˜é‡
- cout.width(8);
>æ§åˆ¶ **ä¸‹ä¸€æ¬¡** coutè¾“å‡ºå®½åº¦è‡³å°‘å¤§äºç­‰äº8
- cout.fill('0');
> **ä¸‹ä¸€æ¬¡** coutè¾“å‡ºä¸å¤Ÿå°±å¡«å……0
- cout << left << "asdasdas"<< endl; 
> æœ¬æ¬¡å·¦å¯¹é½

#### æŠ€å·§
1. è‹¥è¦è¯»å–å•ä¸ªå­—ç¬¦ï¼Œç›´æ¥cin.get(char ch)æˆ–ch=cin.get()å³å¯
> cin.get()çš„è¿”å›å€¼æ˜¯intç±»å‹ï¼ŒæˆåŠŸï¼šè¯»å–å­—ç¬¦çš„ASCIIç å€¼ï¼Œé‡åˆ°æ–‡ä»¶ç»“æŸç¬¦æ—¶ï¼Œè¿”å›EOFï¼Œå³-1ï¼ŒWindowsä¸‹æ ‡å‡†è¾“å…¥è¾“å…¥æ–‡ä»¶ç»“æŸç¬¦ä¸ºCtrl+zï¼ŒLinuxä¸ºCtrl+dã€‚
2. cin.get(str,size);è¯»å–ä¸€è¡Œæ—¶ï¼Œåªèƒ½å°†å­—ç¬¦ä¸²è¯»å…¥Cé£æ ¼çš„å­—ç¬¦ä¸²ä¸­ï¼Œå³char*ï¼Œä½†æ˜¯C++çš„getlineå‡½æ•°è¿˜å¯ä»¥å°†å­—ç¬¦ä¸²è¯»å…¥C++é£æ ¼çš„å­—ç¬¦ä¸²ä¸­ï¼Œå³stringç±»å‹ã€‚


3. while(cin>>s);

æ³¨æ„ while å¤„ç†å¤šä¸ª caseã€‚é€€å‡ºæ–¹æ³•ï¼šå›è½¦åï¼Œåœ¨æ–°è¡ŒCtrl+zå¹¶å›è½¦ã€‚è‹¥è¾“å…¥æ•°æ®åCtrl+zå†å›è½¦æ— æ•ˆã€‚
> è¿™æ˜¯å› ä¸ºï¼šhttps://blog.csdn.net/qq_41543888/article/details/102766294

4. ch = toupper(getchar())
> tolower()/toupper()   c++å†…å»ºå‡½æ•°
```
int tolower(int c)
{
	if ((c >= 'A') && (c <= 'Z'))
		return c + ('a' - 'A');
	return c;
}
 
int toupper(int c)
{
	if ((c >= 'a') && (c <= 'z'))
		return c + ('A' - 'a');
	return c;
}
```

5. è¯»å–ä¸€è¡Œç”¨cin.get(a, 5);
> cin.get(æ•°ç»„åï¼Œé•¿åº¦ï¼Œ[ç»“æŸç¬¦]) ç»“æŸç¬¦å¯é€‰,é»˜è®¤å›è½¦Enter

> å¯¹ç»“æŸç¬¦å¤„ç†ï¼šä¸ä¸¢å¼ƒç¼“å†²åŒºä¸­çš„Enterï¼ˆè‡ªå®šä¹‰ç»“æŸç¬¦æ—¶åŒæ ·ä¸ä¸¢å¼ƒç¼“å†²åŒºä¸­çš„ç»“æŸç¬¦ï¼‰

> ä¼šåœ¨è¯»å–çš„å­—ç¬¦ä¸²åé¢è‡ªåŠ¨åŠ ä¸Š'\0'

```
#include<iostream>
using namespace std;
int main(void){
  char ch='a',a[20];
  cin.get(a,5);
  cin.get(ch);
  cout<<a<<"--"<<(int)ch<<endl;  Enter çš„asciiä¸º10
return 0;
}

è¾“å…¥ï¼š
1 23å›è½¦
è¾“å‡º:
1 23--10
```
6. è¯»å–ä¸€è¡Œç”¨getline
> cin.getline(æ•°ç»„åï¼Œé•¿åº¦ï¼Œ[ç»“æŸç¬¦]) ç»“æŸç¬¦å¯é€‰,é»˜è®¤å›è½¦Enter, i.e., '\n'

> getline()çš„åŸå‹æ˜¯ istream& getline ( istream &is , string &str , char delim ); 
>> cinå°±æ˜¯ä¸€ä¸ªè¾“å…¥æµ

> ä¼šåœ¨è¯»å–çš„å­—ç¬¦ä¸²åé¢è‡ªåŠ¨åŠ ä¸Š'\0'


7. é‰´äºgetlineè¾ƒcin.get()çš„ä¼˜ç‚¹ï¼Œå»ºè®®ä½¿ç”¨getlineè¿›è¡Œè¡Œçš„è¯»å–ã€‚åŒºåˆ«ï¼š

- cin.get()å½“è¾“å…¥çš„å­—ç¬¦ä¸²è¶…è¿‡è§„å®šé•¿åº¦æ—¶ï¼Œä¸ä¼šå¼•èµ·cinå‡½æ•°çš„é”™è¯¯ï¼Œåé¢çš„cinæ“ä½œä¼šç»§ç»­æ‰§è¡Œï¼Œåªæ˜¯ç›´æ¥ä»ç¼“å†²åŒºä¸­å–æ•°æ®ã€‚

ä½†æ˜¯cin.getline()å½“è¾“å…¥è¶…è¿‡è§„å®šé•¿åº¦æ—¶ï¼Œä¼šå¼•èµ·cinå‡½æ•°çš„é”™è¯¯ï¼Œåé¢çš„cinæ“ä½œå°†ä¸å†æ‰§è¡Œã€‚


å½“è¾“å…¥çš„å­—ç¬¦æ•°å¤§äºcountæ—¶ï¼Œåˆ™getå‡½æ•°åªè¯»å–count-1ä¸ªå­—ç¬¦ï¼Œè€Œå…¶ä½™çš„å­—ç¬¦ä»ç„¶ä¿å­˜åœ¨ç¼“å†²åŒºä¸­ï¼Œè¿˜å¯å†å¯¹å…¶è¿›è¡Œè¯»å–ï¼›

ä½†æ˜¯å‡½æ•°getlineåˆ™ä¸ç„¶ï¼Œgetline()ä¼šè®¾ç½®å¤±æ•ˆä½(faibit)ï¼Œå¹¶ä¸”å…³é—­åé¢çš„è¾“å…¥ï¼Œè¿™ä¸ªæ—¶å€™å† ç”¨ch=cin.get()æ˜¯è¯»å–ä¸åˆ°ç•™åœ¨è¾“å…¥é˜Ÿåˆ—ä¸­çš„å­—ç¬¦çš„ã€‚
å¯ä»¥ç”¨ä¸‹é¢çš„å‘½ ä»¤æ¥æ¢å¤è¾“å…¥ï¼š

cin.clear()ï¼› //å› ä¸ºclear()ä¼šé‡ç½®å¤±æ•ˆä½ï¼Œæ‰“å¼€è¾“å…¥ã€‚è¿™ä¸ªæ—¶å€™ch=cin.get();å°±å¯ä»¥è¯»å–ç•™åœ¨è¾“å…¥é˜Ÿåˆ—ä¸­çš„å­—ç¬¦ã€‚
- cin.getè¯»å–ä¸€è¡Œæ—¶ï¼Œé‡åˆ°æ¢è¡Œç¬¦(è‡ªå®šä¹‰ç»“æŸç¬¦)æ—¶ç»“æŸè¯»å–ï¼Œä½†æ˜¯ä¸å¯¹æ¢è¡Œç¬¦(è‡ªå®šä¹‰ç»“æŸç¬¦)è¿›è¡Œå¤„ç†ï¼Œæ¢è¡Œç¬¦(è‡ªå®šä¹‰ç»“æŸç¬¦)ä»ç„¶æ®‹ç•™åœ¨è¾“å…¥ç¼“å†²åŒºã€‚

**getlineè¯»å–ä¸€è¡Œå­—ç¬¦æ—¶ï¼Œé»˜è®¤é‡åˆ°â€™\nâ€™(è‡ªå®šä¹‰ç»“æŸç¬¦)æ—¶ç»ˆæ­¢ï¼Œå¹¶ä¸”å°†â€™\nâ€™(è‡ªå®šä¹‰ç»“æŸç¬¦)ç›´æ¥ä»è¾“å…¥ç¼“å†²åŒºä¸­åˆ é™¤æ‰ï¼Œä¸ä¼šå½±å“ä¸‹é¢çš„è¾“å…¥å¤„ç†**ã€‚

ä¸¤è€…éƒ½ä¼šåœ¨è¯»å–çš„å­—ç¬¦ä¸²åé¢è‡ªåŠ¨åŠ ä¸Š'\0'

- cin.get(str,size);è¯»å–ä¸€è¡Œæ—¶ï¼Œåªèƒ½å°†å­—ç¬¦ä¸²è¯»å…¥Cé£æ ¼çš„å­—ç¬¦ä¸²ä¸­ï¼Œå³char*ï¼Œä½†æ˜¯C++çš„getlineå‡½æ•°è¿˜å¯ä»¥å°†å­—ç¬¦ä¸²è¯»å…¥C++é£æ ¼çš„å­—ç¬¦ä¸²ä¸­ï¼Œå³stringç±»å‹ã€‚ï¼ˆstring test; getline(cin,test);ï¼‰


8. [æ¸…æ¥šç¼“å†²åŒºçš„4ç§åŠæ³•](https://blog.csdn.net/cpp_learner/article/details/104178769?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1-104178769-blog-79067941.pc_relevant_default&utm_relevant_index=1)


9. #include<sstream>
- ä½¿ç”¨sstream::stringstreamè¾“å…¥è¾“å‡ºæµè¿›åˆ¶è½¬æ¢
```
	stringstream ss;
	string tmp;
	int a = 10;
	ss << hex << a;
	ss >> tmp;
	cout << tmp<< endl;//è¾“å‡º a
```


### å­—ç¬¦ä¸²æ“ä½œä¸asciiç 
1. å­—ç¬¦ä¸²ä¸­çš„æŸä¸€ä¸ªå­—ä¸²å…¨æ›¿æ¢ä¸ºå¦ä¸€ä¸ªä¸²
```
string& replace_all(string& src, const string& old_value, const string& new_value) {
	// æ¯æ¬¡é‡æ–°å®šä½èµ·å§‹ä½ç½®ï¼Œé˜²æ­¢ä¸Šè½®æ›¿æ¢åçš„å­—ç¬¦ä¸²å½¢æˆæ–°çš„old_value
	for (string::size_type pos(0); pos != string::npos; pos += new_value.length()) {
		if ((pos = src.find(old_value, pos)) != string::npos) {
			src.replace(pos, old_value.length(), new_value);
		}
		else break;
	}
	return src;

}
```
2. å³ä½¿strå­—ç¬¦ä¸²é•¿åº¦ä¸è¶³8ï¼Œstr.substr(0, 8)ä¹Ÿèƒ½æ­£å¸¸è·å–å‰©ä½™çš„å­—ç¬¦ï¼Œä¸ä¼šæŠ¥é”™ã€‚
```
int main()
{
	string str;
	cin >> str;
	cout << str.substr(0, 8) << endl;
	return 0;
}
```

3. å­—ç¬¦ä¸²è½¬æ•°å€¼ï¼Œå¯ä»¥ç”¨å†…å»ºå‡½æ•°å¦‚ stoll stoi stof stod
> int stoi (const string& str, size_t* idx = 0, int base = 10); base é»˜è®¤å€¼ä¸º10å³ä»¥åè¿›åˆ¶è§£æï¼Œ idxé»˜è®¤ä¸º nullptrå³å¯ï¼Œè¡¨ç¤ºä»åé¢ç¢°åˆ°æ•°å€¼çš„ç¬¬ä¸€ä¸ªå­—ç¬¦å¼€å§‹è§£æ




```
int main() {
	string str;
	while (cin >> str) {
		cout << stoi(str,nullptr,0) << endl;
	}

	return 0;
}
```

4. è‡ªå·±æŒ‰ç…§é€»è¾‘å®ç°è¿›åˆ¶è½¬æ¢
![åå…­è¿›åˆ¶è½¬10è¿›åˆ¶](ç‰›å®¢ç½‘åä¸ºæœºè¯•é¢˜IDE\HUAWEI_Python_IDE\stoi_str_nullptr_0.gif)
    - åå…­è¿›åˆ¶è½¬10è¿›åˆ¶ è¾“å…¥ '0xAAA'  \to  int32
    > ä½¿ç”¨powå‡½æ•°è¦åŠ å¤´æ–‡ä»¶< cmath > ä¸ç„¶è¿‡ä¸äº†ç¼–è¯‘
    ```
    #include<iostream>
    #include<string>
    #include<cmath>
    using namespace std;

    int main() {
        string str;
        while (cin >> str) {
            int pow_up_num = 0;
            int res = 0;
            for (int i = str.size() - 1; i > 1; i --) {
                if(str[i] >= '0' && str[i] <= '9')
                {
                    res += (str[i] - '0') * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if(str[i] >= 'A' && str[i] <= 'F'){
                    res += (str[i] - 'A'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else if (str[i] >= 'a' && str[i] <= 'f') {
                    res += (str[i] - 'a'+10) * pow(16, pow_up_num);
                    pow_up_num++;
                }
                else {
                    cout << "error input!" << endl;
                    exit(-1);
                }
            }
            cout << res << endl;

        }

        return 0;
    }
    ```

5. å­—ç¬¦ä¸²åè½¬
    - å†…å»ºå‡½æ•°reverse(s,s.begin(),s.end());è®°å¾—åŠ å¤´æ–‡ä»¶#include< algorithm.h >
    - è‡ªå·±å®ç°reverseå‡½æ•°
```
    void reverse_string(string& s, int start, int end) {
        while (start < end) {
            swap(s[start++], s[end--]);
        }
    }
```

6. ä½¿ç”¨æ’åºç®—æ³•sort(s.begin(), s.end());æ—¶å€™è®°å¾—åŠ å¤´æ–‡ä»¶#include< algorithm.h >

7. å•è¯å­—å…¸åº
```
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>

using namespace std;
int main() {
	int N;
	while (cin >> N) {
		//vector<string> res;
		vector<string> s;
		for (int i = 0; i < N; i++) {
			string str;
			cin >> str;
			s.push_back(str);
		}
		sort(s.begin(), s.end()); // str1 > str2 å¯ä»¥è¿™æ ·å¯¹æ¯”å­—ç¬¦ä¸²å•è¯å­—å…¸åº
		for (auto a : s) {
			cout << a << endl;
		}
	}


	return 0;
}
```

8. æ­£åˆ™è¡¨è¾¾å¼+stringstream+getline(ss,t,";")åˆ†å‰²å­—ç¬¦ä¸²

[é¢˜ç›®ï¼šåæ ‡ç§»åŠ¨](https://www.nowcoder.com/practice/119bcca3befb405fbe58abe9c532eb29?tpId=37&tqId=21240&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

- getline()çš„ç¬¬ä¸‰ä¸ªå‚æ•°é»˜è®¤ä¸ºç©ºæ ¼Enter å¯ä»¥è‡ªè¡Œæ›´æ”¹
- ä½¿ç”¨regex_matchè¦åŒ…å«å¤´æ–‡ä»¶ `#include<regex>`
  > https://blog.csdn.net/qq_34802416/article/details/79307102
- ä½¿ç”¨stringstreamåˆ†å‰²å­—ç¬¦ä¸²éœ€è¦å¤´æ–‡ä»¶`#include<sstream>`
  > https://www.cnblogs.com/gamesky/archive/2013/01/09/2852356.html

```
#include<iostream>
#include<string>
#include<regex>
#include <vector>
#include<sstream>
using namespace std;

int main() {
    //ios::sync_with_stdio(false);
    //cin.tie(0), cout.tie(0);
    string s, t;
    while (getline(cin, s)) {
        stringstream ss(s);
        pair<int, int> p(0, 0);
        while (getline(ss, t, ';')) {
            if (t.empty())
                continue;
            string _ = t.substr(1);
            if (regex_match(_, regex("[0-9]*"))) {
                switch (t[0]) {
                case 'A': p.first -= stoi(_); break; //å·¦ç§»
                case 'D': p.first += stoi(_); break; //å³ç§»
                case 'W': p.second += stoi(_); break; //ä¸Šç§»
                case 'S': p.second -= stoi(_); break; //ä¸‹ç§»
                default: break; //æ— æ•ˆ
                }
            }
        }
        cout << p.first << "," << p.second << endl;
    }
    return 0;
}

```

9. ipåœ°å€å’Œæ©ç çš„åˆ¤æ–­ï¼Œåœ°å€çš„åˆ†ç±»
ä¸»è¦æ˜¯å‡ ä¸ªç‚¹è¦åšå¥½åˆ¤æ–­
	1. å¦‚ä½•è¾“å…¥ï¼Œipç”¨ä»€ä¹ˆä¿å­˜
      	- å› ä¸ºipæ˜¯ä»¥é”®ç›˜è¾“å…¥å¦‚ï¼š127.26.135.1~255.255.255.0è¯»å…¥ï¼Œæ‰€ä»¥ä½¿ç”¨ ` getline(cin,s,'~') `åˆ†åˆ«è¯»å–å‰åipå’Œæ©ç ï¼Œ
	2. å¦‚ä½•ç¡®å®šæ˜¯å¿½ç•¥çš„ipåœ°å€ï¼Œä¸ç»Ÿè®¡
      	- ipåœ°å€çš„ç¬¬ä¸€ä¸ªå­—æ®µè½¬intåä¸º 127 æˆ–è€… 0
	3. å¦‚ä½•è¯†åˆ«æ˜¯é”™è¯¯çš„ip
      	- ä¸æ˜¯åˆæ³•çš„ip
         	- ipæ®µä¸ºç©º
         	- ipæ®µå¤§è½¬intåå¤§äº255
         	- ä¸ä¸ºå››ä¸ªIPæ®µï¼Œæˆ–å°‘æˆ–å¤š
	4. å¦‚ä½•è¯†åˆ«æ˜¯é”™è¯¯çš„æ©ç 
      	- æ©ç ç”±è‹¥å¹²ä¸ª1æ¥ä¸Šè‹¥å¹²ä¸ª0ç»„æˆï¼Œé—®é¢˜æ˜¯æ€ä¹ˆæŠŠä¸€ä¸ªå­—ç¬¦ä¸²åšè¯†åˆ«ï¼Œå¯ä»¥æ¯æ¬¡è¯»ä¸€ä¸ªæ®µï¼Œç„¶åå·¦ç§»8ä½ï¼Œæœ€åå­˜åˆ°ä¸€ä¸ªæ— ç¬¦å·çš„intç±»å‹ä¸­ï¼Œç„¶åç”¨ä»¥ä¸‹ä»£ç åˆ¤æ–­æ˜¯ä¸æ˜¯ 111..10..01; ifæ¡ä»¶æ˜¯æŒ‡æ©ç ä¸ä¸ºå…¨0ï¼Œæ©ç ä¸ä¸ºå…¨1ï¼Œæ©ç ç”±è‹¥å¹²ä¸ª1æ¥è‹¥å¹²ä¸ª0
		```
		bool isLegalMask(string ip) {
			istringstream iss(ip);
			string sub;
			unsigned int b = 0;
			//vector<int> v;
			
			while (getline(iss, sub, '.'))  b = (b << 8) + stoi(sub);
			if (b == 0 || b == 0xFFFFFFFF || (((b ^ 0xFFFFFFFF) + 1) | b) != b) {
				return false;
			}
			return true;
		}
		```
	5. å¦‚ä½•è·å–ipåœ°å€çš„æŸä¸€ä¸ªæ®µç„¶åè¿›è¡Œipåœ°å€çš„åˆ†ç±»åˆ¤æ–­
		- ipæ˜¯ä»¥stringè¯»ru
		- ä½¿ç”¨`#include<sstream>`çš„istringstreamç±»å‹ä½œä¸ºè¾“å…¥æµï¼Œç„¶åç”¨whileçš„caseåŠŸèƒ½ä¾æ¬¡è¯»å…¥æ¯ä¸€ä¸ªæ®µï¼Œå­˜åˆ°ä¸€ä¸ªvector<int>ä¸­å³å¯
		```
		istringstream iss(ip); //ç”¨stringstreamä¹Ÿå¯ä»¥
			string sub;
			vector<int> sub_vec;
			while (getline(iss, sub, '.')) sub_vec.push_back(stoi(sub));
		```

10. è¿”å›å­—ç¬¦ä¸²ä¸­é•¿åº¦å¤§äº2çš„åŒ…å«å…¬å…±å…ƒç´ çš„æœ€é•¿é‡å¤å­ä¸²

[é¢˜ç›®ï¼šå¯†ç éªŒè¯åˆæ ¼ç¨‹åº](https://www.nowcoder.com/practice/184edec193864f0985ad2684fbc86841?tpId=37&tqId=21243&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
- éå†æ‰€æœ‰çš„å­ä¸²ï¼Œç»Ÿè®¡å‡ºç°æ¬¡æ•°ï¼Œæš´åŠ›æœ
	```
	#include<iostream>
	#include<string>
	#include<map>
	using namespace std;

	//æš´åŠ›ç ´è§£æ‰¾æœ€é•¿ç›¸åŒå­ä¸²
	string findMaxSubStr(string s) {
		string ret = "";
		
		int size = s.size();
		map<string, int> m;
		for (int len = 3; len < size; len++) { //æ¯æ¬¡checkçš„å­—ç¬¦ä¸²é•¿åº¦
			for (int pos = 0; pos < size; pos++) {//ä»æœ€åä¸€ä¸ªå­—ç¬¦ä¸²å¼€å§‹ç®—èµ·
				if (pos < size && pos + len < size) {
					string sub = s.substr(pos,len);
					m[sub]++;
				}
				

			}
		}

		for (auto i : m) {
			if (i.second >= 2) ret = i.first;
		}
		return ret;
	}

	//ç»Ÿè®¡å­—ç¬¦ç±»å‹
	int statisticStrType(string s) {
		int A = 0, B = 0, C = 0, D = 0;
		for (auto ch : s) {
			if (ch >= 'a' && ch <= 'z') A=1;
			else if (ch >= 'A' && ch <= 'Z') B=1;
			else if (ch >= '0' && ch <= '9') C=1;
			else D=1;
		}
		return (A+B+C+D);

	}

	int main() {
		string psd;
		while (cin >> psd) {
			if (psd.size() < 9) {
				cout << "NG" << endl;
			}
			else if (findMaxSubStr(psd).size() > 2) {
				cout << "NG" << endl;
			}
			else if (statisticStrType(psd) < 3) {
				cout << "NG" << endl;
			}
			else {
				cout << "OK" << endl;
			}

			
		}
		return 0;
	}
	```
- åªéœ€è¦éå†æ‰€æœ‰é•¿åº¦ä¸º3çš„å­—ç¬¦ä¸²ï¼Œå¦‚æœåœ¨å­—ç¬¦ä¸²çš„å…¶å®ƒåœ°æ–¹æ‰¾åˆ°äº†è¿™ä¸ªä¸²å°±è¡¨ç¤ºä¸é€šè¿‡
	> ä½†æ˜¯ç®€å•çš„æ‹¼æ¥`string ss = s.substr(0, pos) + s.substr(pos + 3)`ä¼šå‡ºé—®é¢˜,å½¢å¦‚`021Aaabcbc$as`è¿™æ ·çš„å¯†ç ä¼šè¢«è®¤ä¸ºNG

	> æ‰€ä»¥è¿˜æ˜¯éå†ä¸€éæ‰€æœ‰çš„ä¸‰ä¸ªå­å­—ç¬¦ä¸²åšç»Ÿè®¡ï¼Œä»¥æ­¤æ¥å®ç°ä¼˜åŒ–
	```
	#include <iostream>
	#include <map>
	#include <string>
	using namespace std;
	int main() {
		string s;
		while (cin >> s) {
			//å¯†ç é•¿åº¦éœ€è¦å¤§äº8
			if (s.size() <= 8) {
				cout << "NG" << endl;
				continue;
			}
			//å¯†ç è‡³å°‘æœ‰å››ç§ç±»å‹å­—ç¬¦çš„ä¸‰ç§
			int A = 0, B = 0, C = 0, D = 0;
			bool flag = false;
			for (auto ch : s) {
				if (ch >= 'a' && ch <= 'z') A = 1;
				else if (ch >= 'A' && ch <= 'Z') B = 1;
				else if (ch >= '0' && ch <= '9') C = 1;
				else D = 1;
			}
			if (A + B + C + D >= 3) {
				flag = true;
			}
			else {
				cout << "NG" << endl;
				continue;
			}
			int size = s.size();
			map<string, int> m;
			//å¯†ç ä¸èƒ½æœ‰å¤§äº2åŒ…å«å…¬å…±å…ƒç´ çš„å­å­—ç¬¦ä¸²
			//åªéœ€è¦éå†æ‰€æœ‰é•¿åº¦ä¸º3çš„å­å­—ç¬¦ä¸²å°±å¥½
			for (int pos = 0; pos < size; pos++) {//ä»ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸²å¼€å§‹ç®—èµ·
				if (pos < size && pos + 3 < size) {
					string sub = s.substr(pos, 3);
					m[sub]++;
				}
			}
			for (auto i : m) {
				if (i.second >= 2) {
					flag = false;
					break;
				}
			}

				//021Aaabcbc$
			

			if (flag) {
				cout << "OK" << endl;
			}
			else {
				cout << "NG" << endl;
			}
			
		}
		return 0;
	}

	```
11. string::nposç”¨æ³•ï¼Œå‚è€ƒï¼šhttps://blog.csdn.net/jiejinquanil/article/details/51789682
	> nposå¯ä»¥è¡¨ç¤ºstringçš„ç»“æŸä½å­ï¼Œæ˜¯string::type_size ç±»å‹çš„ï¼Œä¹Ÿå°±æ˜¯findï¼ˆï¼‰è¿”å›çš„ç±»å‹ã€‚findå‡½æ•°åœ¨æ‰¾ä¸åˆ°æŒ‡å®šå€¼å¾—æƒ…å†µä¸‹ä¼šè¿”å›string::npos

12. string or char çš„ä¸€äº›æ–¹æ³•
	- islower(ch) 'a'~'z'
	- isupper(ch) 'A'~'Z'
	- isalpha(ch) 'a'~'z'+'A'~'Z'
	- isalnum(ch) 'a'~'z'+'A'~'Z'+ '0'~'9'
	- C++ä¸­stringç±»ä¸‹çš„beginï¼Œendï¼Œrbeginï¼Œrendçš„ç”¨æ³•ï¼Œè¿”å›è¿­ä»£å™¨ï¼Œåˆ†åˆ«æŒ‡å‘å­—ç¬¦ä¸²çš„ç¬¬ä¸€ä¸ªä½ç½®ï¼Œæœ€åä¸€ä¸ªä½ç½®çš„ä¸‹ä¸€ä¸ªä½ç½®ï¼Œæœ€åä¸€ä¸ªä½ç½®ï¼Œç¬¬ä¸€ä¸ªä½ç½®çš„å‰ä¸€ä¸ªä½ç½®

13. å›æ–‡å­—ç¬¦ä¸²
    - éªŒè¯ä¸€ä¸ªå­—ç¬¦ä¸²æ˜¯ä¸æ˜¯æœ‰æ•ˆçš„å›æ–‡ï¼Œåªè€ƒè™‘å­—æ¯å’Œæ•°å­—å­—ç¬¦ï¼Œå¿½ç•¥å­—æ¯çš„å¤§å°å†™ï¼Œè¿™é‡Œå°†ç©ºå­—ç¬¦ä¸²ä¹Ÿå®šä¹‰ä¸ºæœ‰æ•ˆçš„å›æ–‡
      - å¿½ç•¥å­—ç¬¦ä¸²å¤§å°å†™å¯ä»¥ç”¨tolower(ch)æˆ–è€…æ˜¯toupper(ch)
      - ä»…ä»…è€ƒè™‘æ•°å­—+å­—æ¯ï¼Œå¯ä»¥ç”¨ isalnum(ch)
      - è§£æ³•1ï¼šå»é™¤æ‚ç³…åï¼Œç”¨å­—ç¬¦ä¸²ç¿»è½¬apiï¼Œç„¶åçœ‹çœ‹ç¿»è½¬å‰åæ˜¯å¦ç›¸ç­‰
      - è§£æ³•2ï¼šåŒæŒ‡é’ˆï¼Œå»é™¤æ‚ç³…åï¼Œä»ä¸¤ç«¯å¼€å§‹åˆ†åˆ«åˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œç›¸ç­‰ç§»åŠ¨æŒ‡é’ˆï¼Œå¦åˆ™ä¸æ˜¯å›æ–‡ï¼Œå½“ä¸¤ä¸ªæŒ‡é’ˆç›¸é‡åï¼Œé‚£ä¹ˆå°±æ˜¯å›æ–‡
      - è§£æ³•2ä¼˜åŒ–ï¼Œåœ¨åŸå­—ç¬¦ä¸²ä¸Šåˆ¤æ–­ï¼šå°±æ˜¯è¦ç”¨`while(left < right && !isalnum(ch))`æ¥å¿½ç•¥æ— å…³çš„å­—ç¬¦ï¼Œä»è€ŒåŒ¹é…åˆ°ä¸¤ä¸ªéœ€è¦æ¯”è¾ƒçš„ä½ç½®
    - å­—ç¬¦ä¸²ä¸­æœ‰æ•ˆçš„å›æ–‡å­ä¸²æ•°é‡ï¼Œå‡è®¾è¾“å…¥ä¸ºå·²ç»å¤„ç†è¿‡çš„å­—ç¬¦ä¸²
      - ä¸­å¿ƒæ‰©æ•£ï¼Œå¯ä»¥éå†æ¯ä¸€ä¸ªå¯èƒ½æ˜¯å›æ–‡ä¸­å¿ƒçš„ä½ç½®ï¼Œç„¶åå‘å¤–æ‰©æ•£ï¼Œç›´åˆ°ä¸¤è¾¹å­—ç¬¦ä¸ç›¸ç­‰å°±åœæ­¢æ‰©æ•£
      - ä½†æ˜¯è¦æ³¨æ„å­ä¸²é•¿åº¦ï¼Œå¯èƒ½æ˜¯å¥‡æ•°ä¹Ÿå¯èƒ½æ˜¯å¶æ•°ï¼Œéœ€è¦åˆ†åˆ«è€ƒè™‘
    - æœ€é•¿å›æ–‡å­åºåˆ—ï¼Œç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² s ï¼Œæ‰¾å‡ºå…¶ä¸­æœ€é•¿çš„å›æ–‡å­åºåˆ—ï¼Œå¹¶è¿”å›è¯¥åºåˆ—çš„é•¿åº¦ï¼›è¿™é‡Œå­åºåˆ—å®šä¹‰ä¸ºï¼šä¸æ”¹å˜å‰©ä½™å­—ç¬¦é¡ºåºçš„æƒ…å†µä¸‹ï¼Œåˆ é™¤æŸäº›å­—ç¬¦æˆ–è€…ä¸åˆ é™¤ä»»ä½•å­—ç¬¦å½¢æˆçš„ä¸€ä¸ªåºåˆ—ã€‚
      - `dp[i][j]`è¡¨ç¤ºå­—ç¬¦ä¸²ä¸‹æ ‡ä¸º`[i,j]`å†…çš„æœ€é•¿å­å­—ç¬¦ä¸²
      - åˆå§‹åŒ–ï¼š`0<=i<=j<n` æ—¶ï¼Œ`dp[i][j]`æ‰æœ‰å€¼ï¼Œå¦åˆ™ä¸º0ï¼›ä»»ä½•å•ä¸ªå­—ç¬¦éƒ½æ˜¯å›æ–‡ï¼Œæ‰€ä»¥ `0<=i<n` æ—¶ï¼Œ`dp[i][i]=1`
      - å½“`i<j`æ—¶ï¼Œè€ƒè™‘`s[i]`æ˜¯å¦å’Œ`s[j]`ç›¸ç­‰çš„ä¸¤ç§æƒ…å†µ
        - `s[i]==s[j]`:åœ¨å¾—åˆ°`[i+1,j-1]`ä¹‹é—´çš„æ¡ä»¶ä¸‹ï¼Œåˆåœ¨ä¸¤è¾¹å„åŠ äº†ä¸€ä¸ªå­—ç¬¦ï¼Œæ‰€ä»¥é•¿åº¦+2
        > `dp[i][j]=dp[i+1][jâˆ’1]+2` 
        - `s[i]!=s[j]`:s[i]å’Œs[j]ä¸å¯èƒ½åŒæ—¶ä½œä¸ºä¸€ä¸ªå›æ–‡å­—ç¬¦ä¸²çš„é¦–å°¾ï¼Œæ‰€ä»¥ï¼š
        > `dp[i][j] = max(dp[i+1][j], dp[i][j-1])`
	  - çŠ¶æ€è½¬ç§»éƒ½æ˜¯ä»é•¿åº¦è¾ƒçŸ­è½¬ç§»åˆ°è¾ƒé•¿ï¼Œå³ä¸­å¿ƒæ‰©æ•£ï¼Œæ‰€ä»¥æ³¨æ„å¾ªç¯é¡ºåº
	  	> iä»n-1éå†åˆ°0
		> jä»i+1,éå†åˆ°n-1
	  - dp[0][n-1]å³ä¸ºæœ€é•¿çš„å›æ–‡å­å­—ç¬¦ä¸²


```
#include<iostream>
#include<string>
#include<vector>
using namespace std;

#if 0
//æœ‰æ•ˆçš„å›æ–‡
bool isPalindrome(string s) {
    string sgood;
    for (char ch : s) {
        if (isalnum(ch)) {
            sgood += tolower(ch);
        }
    }
    string sgood_rev(sgood.rbegin(), sgood.rend());
    return sgood == sgood_rev;
}

int main() {
    string s = "asdffdsa";
    cout << isPalindrome(s) << endl;
	return 0;
}
#endif

#if 0
//å­—ç¬¦ä¸²ä¸­æœ‰æ•ˆçš„å›æ–‡å­ä¸²æ•°é‡ è¾“å…¥ä¸ºå·²ç»å¤„ç†è¿‡çš„å­—ç¬¦ä¸²
//éå†æ¯ä¸€ä¸ªå¯èƒ½æ˜¯å›æ–‡ä¸­å¿ƒçš„ä½ç½®ï¼Œç„¶åå‘å¤–æ‰©æ•£ï¼Œç›´åˆ°ä¸¤è¾¹å­—ç¬¦ä¸ç›¸ç­‰å°±åœæ­¢æ‰©æ•£
int countSubstrings(string s) {
    int n = s.size(), ans = 0;
    //å¥‡å¶ä½ç½®ä¸€æ¬¡æ€§å¤„ç†
    /*
    for (int i = 0; i < 2 * n - 1; ++i) {
        int l = i / 2, r = i / 2 + i % 2;
        while (l >= 0 && r < n && s[l] == s[r]) {
            --l;
            ++r;
            ++ans;
        }
    }
    */
    //å¥‡å¶ä½ç½®å¤„ç†
    //å­ä¸²å¥‡æ•°é•¿ ä¸­å¿ƒä¸ºs[i]
    //å­ä¸²å¶æ•°æ•°é•¿ ä¸­å¿ƒä¸ºs[i],s[i+1]
    for (int i = 0; i < n; i++) {
        int l = i, r = i;
        while (l >= 0 && r < n && s[l] == s[r]) {
            --l;
            ++r;
            ++ans;
        }
    }
    for (int i = 0; i < n; i++) {
        int l = i, r = i+1;
        while (l >= 0 && r < n && s[l] == s[r]) {
            --l;
            ++r;
            ++ans;
        }
    }
    return ans;
}

int main() {
    cout << countSubstrings("asajfdsfigghhjhhgg") << endl;
}
#endif

#if 1
int longestPalindromeSubseq(string s) {
    int n = s.length();
    vector<vector<int>> dp(n, vector<int>(n));
    for (int i = n - 1; i >= 0; i--) {
        dp[i][i] = 1;
        char c1 = s[i];
        for (int j = i + 1; j < n; j++) {
            char c2 = s[j];
            if (c1 == c2) {
                dp[i][j] = dp[i + 1][j - 1] + 2;
            }
            else {
                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]);
            }
        }
    }
    return dp[0][n - 1];
}

int main() {
    cout << longestPalindromeSubseq("asajfdsfigghhjhhgg") << endl;
    return 0;
}

#endif
```

14. å°å†™å•è¯å­—æ¯å¼‚ä½è¯ï¼Œæ•°ç»„hashè¡¨åš
```
	//å­—æ¯å¼‚ä½è¯ hashè¡¨ å‡è®¾åªæœ‰å°å†™å­—æ¯
	bool is_bro(string a, string b) {
		if (a == b) return false;
		if (a.size() != b.size()) return false;
		int count[26] = { 0 };
		for (int i = 0; i < a.size(); i++) {
			count[a[i] - 'a']++;
			count[b[i] - 'a']--;
		}
		for (int i = 0; i < 26; i++) {
			if (count[i] != 0) return false;
		}
		return true;

	}
```
15. strcpyçš„å®ç°
	- srcå’Œdestçš„å†…å­˜ä¸é‡å 
	```
	char *strcpy(char * dest,const char * src){
		assert(dest!=NULL && src!= NULL);
		char * ret = dest;
		while((*dest++=*src++)!='\0');
		return ret;

	}
	```

	- srcå’Œdestçš„å†…å­˜é‡å ï¼Œå³ src<=dest<=src+strlen(src) æ„æ€æ˜¯å¦‚æœè¿˜ä»ä½åœ°å€å¼€å§‹å¤åˆ¶ï¼Œä¼šå°†æœªå¤„ç†å¾—åœ°å€ç»™è¦†ç›–æ‰ï¼Œå‡ºé”™ï¼Œæ‰€ä»¥å‡ºç°å†…å­˜é‡å éœ€è¦ä»é«˜åœ°å€å¼€å§‹å¤åˆ¶
    	- memcpyè‡ªå¸¦å†…å­˜é‡å åˆ¤æ–­

	```
	char* my_memcpy(char * dest,const char*src,int len){
		assert(dest!=NULL && src!= NULL);
		char * ret = dest;
		if(dest>=src&&dest<=src+len-1){
			//ç¡®å®šsrc å’Œ destçš„æœ€é«˜åœ°å€
			src = src + len -1;//srcæŒ‡å‘'\0'ä½ç½®
			dest = dest + len -1;
			while(len--){
				*dest--=*src--;
			}
		}else{
			while(len--){
				*dest++=*src++;
			}

		}
		return ret;
	}
	char *strcpy(char * dest,char * src){
		assert(dest!=NULL && src!= NULL);
		char * ret = dest;
		my_memcpy(dest,src,strlen(src)+1);//+1æ„ä¹‰åœ¨äº'\0'
		return ret;
	}
	```

16. myStringç±»çš„å£°æ˜ä¸å®ç°
	```
	class myString
	{
	public:
		myString(const char* str = NULL);
		myString(const myString& other);
		~myString(void);
		myString& operator =(const myString& other); //myStringè¿”å›çš„ç±»å‹ å¿…é¡»æœ‰è¿”å›å€¼
	private:
		char* m_data;
	};

	myString::myString(const char* str) {
		if (str == NULL) {
			m_data = new char[1];
			m_data = '\0';
		}
		else {
			int len = strlen(str);
			m_data = new char[len+1];//+1æ„ä¹‰åœ¨äº'\0'
			strcpy(m_data,str);
		}
	}

	myString::myString(const myString& other) {
		int len = strlen(other.m_data);
		m_data = new char[len + 1];
		strcpy(m_data, other.m_data);
	}

	myString::~myString(void) {
		delete []m_data;
	}

	//èµ‹å€¼å‡½æ•°
	myString& myString::operator=(const myString& other) {//&å¼•ç”¨
		//è€ƒè™‘è‡ªèµ‹å€¼æƒ…å†µ
		if (this == &other) {//&å–åœ°å€ç¬¦å·
			return *this;//è¿”å›å½“å‰å¯¹è±¡æœ¬èº«
		}
		//æ—¢ç„¶æ˜¯èµ‹å€¼ï¼ŒåŸå…ˆå¯èƒ½æœ‰å€¼æˆ–è€…ä¸ºèµ‹åˆå€¼ï¼Œä¸ç®¡æ€ä¹ˆè¯´ï¼Œéƒ½è¦å…ˆæ¸…å†å»º
		delete[]m_data;
		int len = strlen(other.m_data);
		m_data = new char[len + 1];
		strcpy(m_data, other.m_data);
		//ä¸è¦å¿˜è®°return
		return *this;
	}
	```

17. bitset ä¸ stringçš„è½¬æ¢ 
- bitsetè½¬string 
```
	//bit_to_string å°±å¾—è¿™æ ·å†™
	bitset<4> b_val(val);
	string s_b_val =
		b_val.template to_string<char, char_traits<char>,
		allocator<char> >();

	bitset<6> b("10101011");//å‚æ•°ä¸€å®šè¦æ˜¯01ç»„æˆçš„å­—ç¬¦ä¸²å¦åˆ™æŠ¥é”™ï¼Œä¸è¶³6ä½å·¦è¾¹è¡¥0 è¶…è¿‡6ä½åªå–é«˜6ä½101010

```

18. å­—ç¬¦ä¸²ä¹Ÿæœ‰countå‡½æ•°ï¼Œåœ¨algorithmå¤´æ–‡ä»¶é‡Œï¼Œç”¨æ³•ï¼š
```
count(str.begin(),str.end(),str[i]) 
```
ä½†æ˜¯è‡ªå·±ç”¨æ•°ç»„åšhashè¡¨çš„ç»Ÿè®¡ä¹Ÿè¦ä¼š:
```
int Count(char &string,char ch){
	int table[128] = { 0 };
	for (int i = 0; i < s.size(); i++) {
		table[s[i]]++;
	}
	return table[ch];

}
int main() {
	string s;
	while (cin >> s) {
		//ç”¨æ•°ç»„åšhashè¡¨,ä¸‹æ ‡å¯¹åº”asciiå­—ç¬¦ï¼Œå€¼å¯¹åº”å‡ºç°æ¬¡æ•°
		char ch = 'b';
		cout<<Count(s,ch)<<endl;
	}
	return 0;
}


```

#### vector

1. vectorä¸­pairçš„ä½¿ç”¨
   > https://www.jianshu.com/p/4b2884c050dc
2. vector::emplace_back() å’Œ vector::push_back() 

	> emplace_back() å’Œ push_back() çš„åŒºåˆ«ï¼Œå°±åœ¨äºåº•å±‚å®ç°çš„æœºåˆ¶ä¸åŒã€‚push_back() å‘å®¹å™¨å°¾éƒ¨æ·»åŠ å…ƒç´ æ—¶ï¼Œé¦–å…ˆä¼šåˆ›å»ºè¿™ä¸ªå…ƒç´ ï¼Œç„¶åå†å°†è¿™ä¸ªå…ƒç´ æ‹·è´æˆ–è€…ç§»åŠ¨åˆ°å®¹å™¨ä¸­ï¼ˆå¦‚æœæ˜¯æ‹·è´çš„è¯ï¼Œäº‹åä¼šè‡ªè¡Œé”€æ¯å…ˆå‰åˆ›å»ºçš„è¿™ä¸ªå…ƒç´ ï¼‰ï¼›è€Œ emplace_back() åœ¨å®ç°æ—¶ï¼Œåˆ™æ˜¯ç›´æ¥åœ¨å®¹å™¨å°¾éƒ¨åˆ›å»ºè¿™ä¸ªå…ƒç´ ï¼Œçœå»äº†æ‹·è´æˆ–ç§»åŠ¨å…ƒç´ çš„è¿‡ç¨‹ã€‚
#### æ ˆå’Œé˜Ÿåˆ—
1. ä½¿ç”¨é˜Ÿåˆ—å…ˆè¿›å…ˆå‡ºçš„æ€§è´¨ï¼ŒæŒ‰é¡ºåºè®°å½•æµä¸­çš„é¡¹
   > é¢˜ç›®ï¼Œ[HJ19 ç®€å•é”™è¯¯è®°å½•](https://www.nowcoder.com/practice/2baa6aba39214d6ea91a2e03dff3fbeb?tpId=37&tqId=21242&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
   - æš´åŠ›è§£æ³•
     - å¦‚ä½•è®°å½•è¾“å…¥`D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645` å’Œè¿™ä¸ªé”™è¯¯å‡ºç°çš„æ¬¡æ•°
		> é¦–å…ˆè¦è£å‰ªæ–‡ä»¶åï¼Œæœ€å¤šä¸è¶…è¿‡16ä¸ªå­—ç¬¦ï¼Œåœ¨ç”¨ä¸€ä¸ªå­—ç¬¦ä¸²å­˜æ–‡ä»¶åï¼Œä¸€ä¸ªintå­˜è¡Œå·ï¼Œä¸€ä¸ªintå­˜å‡ºç°çš„æ¬¡æ•° æ‰€ä»¥ç”¨vector + pairåšè®°å½•
		```
		vector<pair<pair<string, int>, int> > record_data;//ç”¨æ¥è®°å½•å‡ºç°é”™è¯¯çš„æˆªæ–­å†…å®¹ï¼Œè¡Œå·ï¼Œå‡ºç°çš„æ¬¡æ•°
		```
     - å¦‚ä½•ç»´æŒæœ€æ–°çš„8ä¸ªé”™è¯¯
		> è¾“å‡ºè®°å½•çš„æœ€å8æ¡å†…å®¹
	```
	#include<iostream>
	#include<string>
	#include<map>
	#include<deque>
	#include<vector>
	#include<sstream>
	using namespace std;

	string getFile(string path) {
		istringstream iss(path);
		string sub;
		while (getline(iss, sub, '\\')) continue;
		int size = sub.size();
		if (size > 16) {
			sub = sub.substr(size - 16, size);
		}
		return sub;
	}


	void recordFalt(vector<pair<pair<string, int>, int> >& record_data,string file_name,int line_num) {
		vector<pair<pair<string, int>, int> >::iterator it;
		for (it = record_data.begin(); it < record_data.end(); it++) {
			if (it->first.first == file_name && it->first.second == line_num) {
				it->second += 1;
				return ;
			}
		}
		record_data.push_back(make_pair(make_pair(file_name,line_num),1));
		return;
	}
	
	int main() {
		string path_name;
		int line_num;
		//unordered_map<string, pair<int, int>> map;
		vector<pair<pair<string, int>, int> > record_data;//ç”¨æ¥è®°å½•å‡ºç°é”™è¯¯çš„æˆªæ–­å†…å®¹ï¼Œè¡Œå·ï¼Œå‡ºç°çš„æ¬¡æ•°
		//vector<pair<string, int>> res;//è®°å½•è¾“å‡ºæˆªæ–­æ–‡ä»¶å+è¡Œå·
		while (cin >> path_name >> line_num) {
			string file_name = getFile(path_name);
			recordFalt(record_data, file_name, line_num);
		}
		vector<pair<pair<string, int>, int> >::iterator it1;
		if (record_data.size() < 8) {
			
			for (it1 = record_data.begin(); it1 != record_data.end(); it1++) {

				cout << it1->first.first << " " << it1->first.second << " " << it1->second << endl;
			}
		}
		else {

			for (it1 = record_data.begin()+(record_data.size()-8); it1 != record_data.end(); it1++) {

				cout << it1->first.first << " " << it1->first.second << " " << it1->second << endl;
			}
		}
		return 0;
	}


	```
   - ä½¿ç”¨åŒç«¯é˜Ÿåˆ—deque+mapæ±‚è§£, ä»£ç +æ³¨é‡Š
     - å¦‚ä½•å­˜è¾“å…¥
		> ä½¿ç”¨map,ä¸€ä¸ªstringå­˜file_name+lineæ¥åškey,valueä¸ºè¿™ä¸ªé”™è¯¯å‡ºç°çš„æ¬¡æ•°
	 - ä½¿ç”¨åŒç«¯é˜Ÿåˆ—æ¥ç»´æŒæœ€æ–°çš„8ä¸ªé”™è¯¯ï¼Œå¦‚æœdequeé•¿åº¦å¤§äº8ï¼Œåªè¦æ–¹ä¾¿åœ°`d.pop_front()`å³å¯
	```
	#include<iostream>
	#include<string>
	#include<map>
	#include<deque>
	#include<vector>
	#include<sstream>
	using namespace std;

	//ç”¨åŒç«¯é˜Ÿåˆ—deque+mapæ¥åš
	int main() {
		//æ•´ä¸ªè¡Œè¾“å…¥åšå­—ç¬¦ä¸²,å³file_name+line_num
		string name_line;
		//ä½¿ç”¨hashæ˜ å°„æ¥å­˜å‚¨å‡ºç°çš„æ¬¡æ•°
		map<string, int> m;
		//ä½¿ç”¨é˜Ÿåˆ—ç»´æŒæœ€æ–°çš„8ä¸ªé”™è¯¯
		deque<string> res;
		while (getline(cin, name_line)) {
			//è£å–æˆªæ–­æ–‡ä»¶å+è¡Œå·
			name_line = name_line.substr(name_line.find_last_of('\\') + 1);
			int pos = name_line.find_last_of(" ");
			if (pos > 16) {
				name_line = name_line.substr(pos - 16);
			}

			//è®°å½•é”™è¯¯å‡ºç°çš„æ¬¡æ•°
			if (m.find(name_line) == m.end()) {
				res.push_back(name_line);
			}
			++m[name_line];

			//ç»´æŒ8ä¸ªåœ¨æ¡ˆé”™è¯¯
			if (res.size() > 8) {
				res.pop_front();
			}
		}

		for (auto it : res) {
			cout << it << " " << m[it] << endl;
		}


		return 0;
	}


	```

2. è¡¨è¾¾å¼æ±‚å€¼-æ ˆ-å­—ç¬¦ä¸²è¯†åˆ«-è¿ç®—ç¬¦ä¼˜å…ˆçº§-åŒæ ˆæ³•
[é¢˜ç›®](https://www.nowcoder.com/practice/9566499a2e1546c0a257e885dfdbf30d?tpId=37&tqId=21277&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D2%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
- ç»™å®šä¸€ä¸ªå­—ç¬¦ä¸²æè¿°çš„ç®—æœ¯è¡¨è¾¾å¼ï¼Œè®¡ç®—å‡ºç»“æœå€¼ã€‚
- è¾“å…¥å­—ç¬¦ä¸²é•¿åº¦ä¸è¶…è¿‡ 100 ï¼Œåˆæ³•çš„å­—ç¬¦åŒ…æ‹¬ â€+, -, *, /, (, )â€ ï¼Œ â€0-9â€ ã€‚
- æ•°æ®èŒƒå›´ï¼šè¿ç®—è¿‡ç¨‹ä¸­å’Œæœ€ç»ˆç»“æœå‡æ»¡è¶³ $|val| \le 2^{31}-1$  ï¼Œå³åªè¿›è¡Œæ•´å‹è¿ç®—ï¼Œç¡®ä¿è¾“å…¥çš„è¡¨è¾¾å¼åˆæ³•
```
#include<iostream>
#include<string>
#include<stack>
#include"assert.h"
using namespace std;

void caculate_num_op_num(stack<int>& num_st, stack<char> &op_st) {
	if (num_st.size() < 2 || op_st.empty()) return;
	int rhs = num_st.top();
	num_st.pop();
	int lhs = num_st.top();
	num_st.pop();
	char op = op_st.top();
	op_st.pop();
	if (op == '+') num_st.push(lhs + rhs);
	else if (op == '-') num_st.push(lhs - rhs);
	else if (op == '*') num_st.push(lhs * rhs);
	else if (op == '/' && rhs != 0) num_st.push(lhs / rhs);
}

bool priority(char in_stack, char into_stack) {
	if (in_stack == '(') return false;
	else if ((in_stack == '+' || in_stack == '-') && (into_stack == '*' || into_stack == '/')) return false;
	return true;
}

int caculateVal(string s) {
	stack<int> num_st;
	stack<char> op_st;
	int res = 0;
	bool flag = false;
	op_st.push('(');
	s += ')';
	for (int i = 0; i < s.size(); i++) {
		if (s[i] == '(') {
			op_st.push(s[i]);
		}
		else if (s[i] == ')') {
			while (op_st.top() != '(') caculate_num_op_num(num_st, op_st);
			op_st.pop();
		}
		else if(flag) {
			//æ“ä½œç¬¦
			while(!op_st.empty()&&priority(op_st.top(),s[i])) caculate_num_op_num(num_st, op_st);  //ç®—å®Œ  è¿™é‡Œçš„whileå¾ˆé‡è¦ï¼Œä¸èƒ½æ˜¯if
			if (s[i] == '+') op_st.push('+');
			else if (s[i] == '-') op_st.push('-');
			else if (s[i] == '*') op_st.push('*');
			else if (s[i] == '/') op_st.push('/');
			flag = false;
		}
		else {
			//æ“ä½œæ•°
			int num =  stoi(s.substr(i));
			num_st.push(num);
			int len = to_string(num).size();
			i += len - 1;
			flag = true;
		}
	}
	return num_st.top();
}

int main() {
	string s;
	while (cin >> s) {

		cout << caculateVal(s) << endl;
	
	}
	return 0;
}

```


#### hashè¡¨
> å‚è€ƒï¼š[PiaYie-ä»£ç éšæƒ³å½•ï¼šå“ˆå¸Œè¡¨](https://www.cnblogs.com/PiaYie/p/15877059.html)

1. å¤šå¯¹ä¸€ç”¨æ³•ï¼š[ç®€å•å¯†ç ](https://www.nowcoder.com/practice/7960b5038a2142a18e27e4c733855dac?tpId=37&tqId=21244&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
	```
	#include<iostream>
	#include<string>
	#include<unordered_map>
	using namespace std;

	#if 0
	int main() {
		string pwd;
		string res = "";
		while (cin >> pwd) {
			for (auto ch : pwd) {
				if (ch == '1') res+=ch;
				else if (ch == '1') continue;
				else if (ch >= 'a' && ch <= 'c') res += '2';
				else if (ch >= 'd' && ch <= 'f') res += '3';
				else if (ch >= 'g' && ch <= 'i') res += '4';
				else if (ch >= 'j' && ch <= 'l') res += '5';
				else if (ch >= 'm' && ch <= 'o') res += '6';
				else if (ch >= 'p' && ch <= 's') res += '7';
				else if (ch >= 't' && ch <= 'v') res += '8';
				else if (ch >= 'w' && ch <= 'z') res += '9';
				else if (ch >= 'A' && ch <= 'Z') {
					ch = tolower(ch) + 1;
					if (ch == '{') ch = 'a';
					res += ch;
				}
				else res += ch;
			}
			cout << pwd << endl;
		}
		return 0;
	}
	#endif

	#if 1
	//ä½¿ç”¨mapæ–¹æ³•åªéœ€è¦åˆ¤æ–­å¤§å°å†™
	int main() {
		string s;
		unordered_map<char, char> m;
		m['a'] = m['b'] = m['c'] = '2';
		m['d'] = m['e'] = m['f'] = '3';
		m['g'] = m['h'] = m['i'] = '4';
		m['j'] = m['k'] = m['l'] = '5';
		m['m'] = m['n'] = m['o'] = '6';
		m['p'] = m['q'] = m['r'] = m['s'] = '7';
		m['t'] = m['u'] = m['v'] = '8';
		m['w'] = m['x'] = m['y'] = m['z'] = '9';
		while (cin >> s) {
			//åŸåœ°ä¿®æ”¹èŠ‚çœç©ºé—´
			for (int i = 0; i < s.size(); i++) {
				if (islower(s[i])) s[i] = m[s[i]];
				else if (isupper(s[i]) && s[i]!='Z') {
					s[i] = s[i] - 'A' + 'a' + 1;
				}
				if (s[i] == 'Z') s[i] = 'a';
			}
			cout << s << endl;
		}

		return 0;
	}
	#endif


	```


### æš´åŠ›ç ´è§£
1. è´¨æ•°åˆ†è§£å®šç†
> https://www.cnblogs.com/wellerency/p/15868807.html

![è´¨æ•°åˆ†è§£å®šç†](ç‰›å®¢ç½‘åä¸ºæœºè¯•é¢˜IDE\HUAWEI_Python_IDE\è´¨æ•°åˆ†è§£å®šç†.png)
- åˆ¤å®šè´¨æ•°å’Œåˆ†è§£è´¨å› æ•°
- è¾¹ç•Œæ¡ä»¶å¯é€‰ 
  - i <= sqrt(N)
  - i <= N/i
```
#include<iostream>
#include<vector>
using namespace std;


//è´¨æ•°åˆ†è§£å®šç† ä¸€ä¸ªå¤§äº1çš„æ•°å…¶è´¨æ•°åˆ†è§£å½¢å¼æ˜¯å”¯ä¸€çš„ã€‚
int main() {

	int N;
	//vector<int> res;
	while (cin >> N) {
		if (N == 1) {
			cout << N << " " << N << endl;
		}
		
		for (int i = 2; i <= N / i; i++) {
			//M*èƒ½å¤Ÿæ•´é™¤i
			if (N % i == 0) {
				int cnt = 0;
				while (N % i == 0) {
					cnt++;
					//s.push_back(i);
					N /= i;
					//if (cnt) cout << i << " " << cnt << endl;
					if (cnt) cout << i << " ";
				}
			}
		}
		//if (N > 1) cout << N << " " << 1<< endl;
		if (N > 1) cout << N << endl;
	
	}

	return 0;
}

```
### å¿«é€Ÿæ’åº
> ç»å…¸æ’åºç®—æ³•æ€»ç»“ï¼šhttps://www.cnblogs.com/fnlingnzb-learner/p/9374732.html

> ç»å…¸æ’åºç®—æ³•æ€»ç»“ï¼ˆåŠ¨å›¾ï¼‰ï¼šhttps://www.cnblogs.com/onepixel/articles/7674659.html

1. å†’æ³¡æ’åºæ³• $O(n^2)$
![å†’ç‰Œæ’åºæ³•æ€è·¯å›¾](ç‰›å®¢ç½‘åä¸ºæœºè¯•é¢˜IDE\HUAWEI_Python_IDE\mppxf.gif)
```
//å†’æ³¡æ’åº
void BubbleSort(int* h, size_t len)
{
    if (h == NULL) return;
    if (len <= 1) return;
    //iæ˜¯æ¬¡æ•°ï¼Œjæ˜¯å…·ä½“ä¸‹æ ‡
    for (int i = 0; i < len - 1; ++i)
        for (int j = 0; j < len - 1 - i; ++j)
            if (h[j] > h[j + 1])
                Swap(h[j], h[j + 1]);

    return;
}
```


2. å¿«é€Ÿæ’åº $O(n\log_2 n)$
   - å†…å»ºå‡½æ•° sort(s.begin(), s.end()); æ˜¯algorithmä¸­çš„å‡½æ•°éœ€è¦å¤´æ–‡ä»¶
   - è‡ªå·±å®ç°

![å¿«é€Ÿæ’åºæ³•æ€è·¯å›¾](ç‰›å®¢ç½‘åä¸ºæœºè¯•é¢˜IDE\HUAWEI_Python_IDE\kspxf.gif)
```
//å¿«é€Ÿæ’åºï¼Œéšæœºé€‰å–å“¨å…µæ”¾å‰é¢
void QuickSort(int* h, int left, int right)
{
    if (h == NULL) return;
    if (left >= right) return;

    //é˜²æ­¢æœ‰åºé˜Ÿåˆ—å¯¼è‡´å¿«é€Ÿæ’åºæ•ˆç‡é™ä½
    srand((unsigned)time(NULL));  // include"time.h"
    int len = right - left;
    int kindex = rand() % (len + 1) + left;
    Swap(h[left], h[kindex]);
    //ç¬¬ä¸€ä¸ªå…ƒç´ ä½œä¸ºå“¨å…µï¼ŒæŠŠæ¯”å“¨å…µå¤§çš„å…ƒç´ å…¨ç§»åˆ°å“¨å…µçš„å³è¾¹ï¼Œè¿™æ—¶å€™å¯ä»¥ä¸ç®¡å“¨å…µå·¦è¾¹å’Œå³è¾¹çš„åºåˆ—æ˜¯å¦æœ‰åºç”šè‡³æ˜¯å¦å±€éƒ¨æœ‰åº
    //æœ‰åºçš„åŸå› æ˜¯è¿™ä¸ªæ­¥éª¤+é€’å½’çš„ä½œç”¨
    int key = h[left], i = left, j = right;
    while (i < j)
    {
        while (h[j] >= key && i < j) --j;
        if (i < j) h[i] = h[j];//ä»jå¾€å·¦æŠŠé‡åˆ°çš„ç¬¬ä¸€ä¸ªå°äºå“¨å…µçš„æ•°å¾€å‰æ‰”ï¼Œå“¨å…µè¢«è¦†ç›–ï¼Œä½†æ˜¯å¤‡ä»½åˆ°keyäº†  è¢«æ‰”çš„è¿™ä¸ªä½ç½®å°±ç©ºå‡ºæ¥äº†
        while (h[i] < key && i < j) ++i;
        if (i < j) h[j] = h[i];//ä»iå¾€å³æŠŠé‡åˆ°çš„ç¬¬ä¸€ä¸ªå¤§äºç­‰äºå“¨å…µçš„æ•°å¾€åˆšåˆšç©ºå‡ºçš„ä½ç½®åŠ å¡ï¼Œè¿™æ—¶å€™çš„è¿™ä¸ªä½ç½®s[i]å…¶å®æ˜¯éœ€è¦æ”¾ä¸€ä¸ªå…ƒç´ è¿›æ¥çš„ï¼ˆå¦‚æœæœ‰æ¯”å“¨å…µå°çš„å½“ç„¶å¥½ï¼Œå®åœ¨æ‰¾ä¸åˆ°äº†,æŠŠå¤‡ä»½çš„å“¨å…µæ”¾è¿›æ¥ï¼‰
    }

    h[i] = key;
    //æœ€åé€’å½’ï¼Œå®ç°æœ‰åº
    QuickSort(h, left, i - 1);
    QuickSort(h, j + 1, right);
}
```

3. è¾“å…¥nä¸ªæ•´æ•°ï¼Œè¾“å‡ºæœ€å°çš„kä¸ª
æ€è·¯ï¼šå¿«é€Ÿæ’åºï¼Œ æˆ–è€…ç”¨ä¼˜å…ˆé˜Ÿåˆ—priority_queue
```
#include <iostream>
#include <algorithm>
#include<time.h>
#include<vector>
#include<queue>
#include"assert.h"
using namespace std;


#if 0
//å¿«æ’
void Qsort(vector<int>& nums,int left,int right) {
	int len = right - left;
	if (nums.empty()) return;
	if (left >= right) return;
	//éšæœºç”Ÿæˆä¸€ä¸ªk
	srand((unsigned int)time(NULL));
	int k = left + rand() % (len + 1);
	swap(nums[left], nums[k]);

	//æ‰§è¡Œå¿«æ’
	int i = left, j = right;
	int key = nums[i];
	while (i < j) { // 
		while (i<j && nums[j]>key) --j;
		if (i < j) nums[i] = nums[j];
		while (i < j && nums[i] < key) ++i;
		if (i < j) nums[j] = nums[i];
	}
	//i=j
	nums[i] = key;
	//é€’å½’
	Qsort(nums, left, i - 1);
	Qsort(nums, j+1, right);
}


//å¿«é€Ÿæ’åº
int main() {
	int n, k,t;
	while (cin >> n >> k) {
		vector<int> nums;
		for (int i = 0; i < n; i++) {
			cin >> t;
			nums.push_back(t);
		}
		Qsort(nums,0,nums.size()-1);
		assert(k <= n);
		for (int i = 0; i < k; i++) {
			cout << nums[i] << " ";
		}
		cout << endl;
	}
}

#endif


//å¤§å°å †
#if 1

//é‡å†™æ¯”è¾ƒå‡½æ•°
struct cmp {
	bool operator() (int lhs, int rhs) {
		return lhs > rhs;
	}

};

//å°é¡¶å †
int main() {
	int n, k, t;
	while (cin >> n >> k) {
		vector<int> nums;
		priority_queue<int,vector<int>,cmp> min_queue;
		for (int i = 0; i < n; i++) {
			cin >> t;
			nums.push_back(t);
			min_queue.push(t);
		}
		while (k--&&k<=min_queue.size()) {
			cout << min_queue.top() << " ";
			min_queue.pop();
		}
	}
}

#endif

```

### æ’åˆ—ç»„åˆ
### äºŒåˆ†æŸ¥æ‰¾
### é€’å½’
1. ç´ æ•°ä¼´ä¾£ - åŒˆç‰™åˆ©ç®—æ³• - äºŒåˆ†å›¾(æŒ‰ç‰¹å®šçš„è§„åˆ™è¿çº¿æœ€å¤š)è¿çº¿æœ€å¤šç®—æ³•
> ç»™å®šå¶æ•°ä¸ªæ­£æ•´æ•°, é—®æœ€å¤šèƒ½æ‰¾åˆ°å¤šå°‘ç»„æ•°å¯¹ï¼Œä½¿å¾—ä»–ä»¬çš„å’Œä¸ºç´ æ•°
   - é¦–å…ˆè¦ç»™æ•°åˆ†ä¸ºä¸¤ç»„ï¼Œå¥‡æ•°å’Œå¶æ•°ï¼Œå¦‚æœå…¶ä¸­æœ‰ä¸€ä¸ªæ•°ç»„ä¸ºç©ºï¼Œåˆ™ä¸å¯èƒ½æ„æˆâ€œç´ æ•°ä¼´ä¾£â€
   - åå°±ç›¸å½“äºæ˜¯å·¦è¾¹ä¸€äº›å¥‡æ•°å…ƒç´ çš„ç‚¹ï¼Œè¦è¿åˆ°å³è¾¹å¶æ•°å…ƒç´ ä¸Šé¢ï¼Œè¿™å°±æ˜¯äºŒåˆ†å›¾è¿çº¿æœ€å¤šçš„é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ç”¨åŒˆç‰™åˆ©ç®—æ³•ã€‚
   - é¦–å…ˆæˆ‘ä»¬éå†å·¦è¾¹å¥‡æ•°æ•°ç»„ï¼Œå¯¹æ¯ä¸€ä¸ªå…ƒç´ éƒ½æŸ¥æ‰¾èƒ½å¦åœ¨å¶æ•°æ•°ç»„ä¸­æ‰¾åˆ°é…å¯¹çš„æ•°ï¼ŒæŸ¥æ‰¾æ—¶æˆ‘ä»¬éå†å¶æ•°æ•°ç»„ï¼Œå¦‚æœè¯¥å¶æ•°èƒ½å’Œè¿™ä¸ªå¥‡æ•°åŒ¹é…ï¼Œä¸”åœ¨è¿™ä¸€è½®è¿™ä¸ªå¶æ•°æ²¡è¢«ç”¨è¿‡ï¼Œæˆ‘ä»¬å†æ£€æŸ¥è¿™ä¸ªmatchæ•°ç»„ï¼ˆè¡¨ç¤ºç°é˜¶æ®µå¶æ•°åŒ¹é…çš„å¯¹è±¡ï¼‰ï¼Œå¦‚æœmatchæ•°ç»„ä¸­è¿™ä¸ªå¶æ•°æ²¡æœ‰åŒ¹é…å¯¹è±¡ï¼Œæˆ–è€…é€’å½’æŸ¥æ‰¾è¿™ä¸ªåŒ¹é…å¯¹è±¡å¯ä»¥æœ‰å…¶ä»–çš„å¶æ•°åŒ¹é…ï¼Œé‚£æˆ‘ä»¬ä¿®æ”¹è¯¥åŒ¹é…å¯¹è±¡ä¸ºè¿™ä¸ªå¥‡æ•°ï¼Œä»£è¡¨èƒ½æ‰¾åˆ°åŒ¹é…ã€‚
   - åˆ›å»ºä¸€ä¸ªç´ æ•°è¡¨ï¼Œç”¨ç©ºé—´æ¢æ—¶é—´
```
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <limits.h>
#include <math.h>
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

bool isPrime(int m) {
	if (m <= 1) return false;
	for (int i = 2; i < sqrt(m); i++) {
		if (m % i == 0) return false;
	}
	return true;
}

//å»ºç«‹Né•¿è´¨æ•°checkè¡¨ æ¬§æ‹‰çº¿æ€§è´¨æ•°ç­›
void buildPrimeTable(int N, bool* isprime_t, int *prime_t,int &count) {
	int cnt=0;
	isprime_t[0] = isprime_t[1] = false;
	for (int i = 2; i < N; i++) {
		if (isprime_t[i]) prime_t[cnt++] = i;//å¦‚æœæ˜¯è´¨æ•°å°±åŠ å…¥åˆ°è´¨æ•°è¡¨ä¸­ï¼Œç”¨æœ€å°çš„è´¨æ•°çš„iå€æå‰æ ‡è®°äº†åé¢çš„è´¨æ•°
		for (int j = 0; j< N; j++) {
			if (i * prime_t[j] >= N) break;
			isprime_t[i * prime_t[j]] = false;//æ¯ä¸€ä¸ªç´ æ•°éƒ½å°†å…¶å½“å‰çš„iå€æ•°æ ‡è®°ä¸ºéç´ æ•°
			if (i % prime_t[j] == 0) break;//æœ€å…³é”®åªæ ‡è®°ä¸€æ¬¡ï¼Œä¸ä¼šé‡å¤æ ‡jè®°ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯ç´ æ•°çš„å€æ•°
		}
		
	}
	count = cnt;
}

void buildisPrimeTable(int N, bool* isprime_t) {
	int cnt = 0;
	int* prime_t = new int[N];
	isprime_t[0] = isprime_t[1] = false;
	for (int i = 2; i < N; i++) {
		if (isprime_t[i]) prime_t[cnt++] = i;//å¦‚æœæ˜¯è´¨æ•°å°±åŠ å…¥åˆ°è´¨æ•°è¡¨ä¸­ï¼Œç”¨æœ€å°çš„è´¨æ•°çš„iå€æå‰æ ‡è®°äº†åé¢çš„è´¨æ•°
		for (int j = 0; j < N; j++) {
			if (i * prime_t[j] >= N) break;
			isprime_t[i * prime_t[j]] = false;//æ¯ä¸€ä¸ªç´ æ•°éƒ½å°†å…¶å½“å‰çš„iå€æ•°æ ‡è®°ä¸ºéç´ æ•°
			if (i % prime_t[j] == 0) break;//æœ€å…³é”®åªæ ‡è®°ä¸€æ¬¡ï¼Œä¸ä¼šé‡å¤æ ‡jè®°ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯ç´ æ•°çš„å€æ•°
		}

	}
	delete []prime_t;
}

bool odd_find_enev_matchbest(int odd, vector<int> &evens, vector<bool> &even_used, vector<int> &even_match, bool *isprime_t) {
	//éå†æ¯ä¸€ä¸ªå¶æ•°ä¸å¥‡æ•°åŒ¹é…
	for (int i = 0; i < evens.size(); i++) {
		if (!even_used[i] && isprime_t[odd + evens[i]]) {
			even_used[i] = true;//è¿™ä¸ªå¶æ•°è¢«ä½¿ç”¨
			//å¦‚æœç¬¬iä¸ªå¶æ•°è¿˜æœªé…å¯¹ï¼Œæˆ–è€…è·Ÿå®ƒé…å¯¹çš„å¥‡æ•°æœ‰åˆ«çš„é€‰æ‹©
			if (even_match[i] == 0 || odd_find_enev_matchbest(even_match[i], evens, even_used, even_match, isprime_t)) {
				even_match[i] = odd;
				return true;
			}
		}
	}
	return false;
}




int main() {
	const int len = 60000;
	bool isprime_t[len];
	memset(isprime_t, true, sizeof(isprime_t));
	buildisPrimeTable(len, isprime_t);
	int N,tmp;
 	while (cin >> N) {
		vector<int> nums(N);
		vector<int> odds;//å¥‡æ•°ç»„
		vector<int> evens;//å¶æ•°ç»„
		for (int i = 0; i < N; i++) {
			cin >> tmp;
			nums[i] = tmp;
			if (tmp % 2 == 0) evens.push_back(tmp);
			else odds.push_back(tmp);
		}
		//ç´ æ•°ä¸€å®šæ˜¯ç”±ä¸€ä¸ªå¥‡æ•°å’Œä¸€ä¸ªå¶æ•°çš„å’Œæ„æˆ
		int count = 0;
		if (odds.size() == 0 || evens.size() == 0) {
			cout << count << endl;
			continue;
		}
		vector<int> even_match(evens.size(), 0);//è®°å½•æ¯ä¸€ä¸ªå¶æ•°[i]åŒ¹é…çš„æ˜¯å“ªä¸€ä¸ªå¥‡æ•°even_match[i]
		for (int i = 0; i < odds.size(); i++) {//éå†æ¯ä¸€ä¸ªå¥‡æ•°
			vector<bool> even_used(evens.size(), false);//è¿™ä¸€è½®å¶æ•°æ²¡æœ‰è¢«ä½¿ç”¨åˆ™æ ‡è®°å€¼ä¸º0
			//å¯¹æ¯ä¸€ä¸ªå¥‡æ•°ï¼Œèƒ½æ‰¾åˆ°æœ€ä¼˜çš„ä¸ä¹‹é…å¯¹çš„å¶æ•°ï¼Œé‚£ä¹ˆåŒ¹é…+1
			if (odd_find_enev_matchbest(odds[i],evens,even_used,even_match,isprime_t)) {
				count++;
			}
		}
		cout << count << endl;
	}

	return 0;
}
```
### ä½è¿ç®—
1. æ­£æ•´æ•°çš„æ±‰æ˜é‡é‡ - å·§ç”¨ num = num & (num - 1)
```
int hmweight_caculate(unsigned int num) {
	// n = n & (n-1)
	int res = 0;
	while (num) {
		res += 1;
		num = num & (num - 1);
	}
	return res;
}
```


### æ»‘åŠ¨çª—å£
1. DNAåºåˆ—ï¼Œå›ºå®šé•¿åº¦çš„å­åºåˆ—çš„æƒé‡æœ€å¤§çš„é‚£ä¸€ä¸ªå­åºåˆ—
```
#include<iostream>
#include<string>
using namespace std;
//åŒæŒ‡é’ˆ 
int main() {
	string s;
	int k;
	while (cin >> s >> k) {
		if (s.size() <= k || k<=0) {
			cout << s << endl;
			continue;
		}
		double maxratio = 0.0;
		int pos = 0;
		int count = 0;
		for (int i = 0; i < s.size(); i++) {
            //å…¥çª—å£ s[i]
			if (s[i] == 'C' || s[i] == 'G') count++;
            //å‡ºçª—å£ s[i - k + 1]
			if (i >= k - 1) {
				if (1.0 * count / k > maxratio) {
					pos = i-k+1;
					maxratio = 1.0 * count / k;
				}
				if (s[i - k + 1] == 'C' || s[i - k + 1] == 'G') {
					count--;
				}
				
			}
		}
		
		cout << s.substr(pos, k) << endl;
	
	}
	return 0;
}
```

2. [MP3æ­Œå•ç•Œé¢æ“ä½œä¸æ˜¾ç¤º](https://www.nowcoder.com/practice/eaf5b886bd6645dd9cfb5406f3753e15?tpId=37&tqId=21287&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D2%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

> ç›´æ¥æ¨¡æ‹Ÿï¼Œæˆ–è€…æ»‘åŠ¨çª—å£ï¼š ï¼ˆå…¥é­”äº†ğŸ˜¡ï¼‰

```
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

int main(){
    int n;
    string commands;
    while(cin >> n >> commands){
        int num = 1;//é€‰ä¸­çš„æ­Œæ›²
        int win_b = 1;//é¡µé¢çš„èµ·å§‹
        int win_e = min(4,n);//é¡µé¢çš„æœ«ä½ç½®
        for(int i = 0; i < commands.size(); i++){
            if(commands[i] == 'U') {//å‘ä¸Šç§»åŠ¨ä¸€æ ¼
                num = (num-1-1+n)%n + 1;
            }else if(commands[i] == 'D') {//å‘ä¸‹ç§»åŠ¨ä¸€æ ¼
                num = num % n + 1;
            }
            if(num < win_b){//å¦‚æœå½“å‰æ­Œæ›²åœ¨çª—å£å‰ï¼Œåˆ™å°†çª—å£å¾€å‰ç§»åŠ¨
                win_b = num;
                win_e = win_b + 3;
            }else if(num > win_e){//å¦‚æœå½“å‰æ­Œæ›²åœ¨çª—å£åï¼Œåˆ™å°†çª—å£å¾€åç§»åŠ¨
                win_e = num;
                win_b = win_e - 3;
            }
        }
        for(int i = win_b; i <= win_e; i++){//è¾“å‡ºå½“å‰é¡µé¢
            cout << i << ' ';
        }
        cout << endl;
        cout << num << endl;//è¾“å‡ºé€‰ä¸­çš„æ­Œæ›²
    }
    return 0;
}



```



### æ·±åº¦ä¼˜å…ˆç®—æ³•DFS
1. [24ç‚¹æ¸¸æˆ](https://www.nowcoder.com/practice/fbc417f314f745b1978fc751a54ac8cb?tpId=37&tqId=21290&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D2%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)
```
#include<iostream>
#include<vector>
#include"assert.h"
#include<sstream>
using namespace std;

double nums[4];
bool flag = false;
bool used[4] = { 0 };
void dfs(int step,double sum) {
	//é€’å½’ç»“æŸæ¡ä»¶
	//æ¯ä¸ªæ•°éƒ½è¦è¢«é€‰å–è®¡ç®—
	if (step == 4) {
		if (sum == 24) {
			flag = true;
			return;
		}
	}
	else {
		step++;
		//éå†å››ä¸ªæ•°å­—
		for (int j = 0; j < 4; j++) {
			if (used[j] == false) {
				used[j] = true;
				dfs(step, sum + nums[j]);
				dfs(step, sum - nums[j]);
				dfs(step, sum * nums[j]);
				dfs(step, sum / nums[j]);
				//å›æº¯
				used[j] = false;
			}

		}
		
	}

	//éšè—çš„return  æ¯ä¸ªæ•°éƒ½è¢«ç”¨äº†ä½†æ˜¯å¾—ä¸åˆ°24
}

int main() {
	for (int i = 0; i < 4; i++) {
		cin >> nums[i];
	}
	dfs(0,0);
	if (flag == true) cout << "true" << endl;
	else cout << "false" << endl;


	return 0;
}

```

2. [è¿·å®«æ‰¾å‡ºå£ - dfs](https://www.nowcoder.com/practice/cf24906056f4488c9ddb132f317e03bc?tpId=37&tqId=21266&rp=1&ru=/exam/oj/ta&qru=/exam/oj/ta&sourceUrl=%2Fexam%2Foj%2Fta%3Fpage%3D1%26tpId%3D37%26type%3D37&difficulty=undefined&judgeStatus=undefined&tags=&title=)

   - DFSæŒ‰å›ºå®šé¡ºåºèµ°åˆ°é»‘ï¼Œè¿™é‡Œæ¯ä¸€ä¸ªä½ç½®å¯¹åº”4ä¸ªå‘¨è¾¹å…ƒç´ ï¼Œä¸Šä¸‹å·¦å³
   - DFSå›æº¯é‡è¦çš„é—®é¢˜ä¸€æ˜¯æ€ä¹ˆä¸ªé€’å½’æ³•ï¼Œäº‹å…³å‡½æ•°å‚æ•°çš„é€‰å–ï¼›äºŒæ˜¯æ€ä¹ˆç¡®å®šé€’å½’ç»“æŸæ¡ä»¶ï¼›åœ¨é€‚å½“çš„æ—¶å€™åšå‡æã€‚

```
#include<iostream>
#include<vector>

using namespace std;
vector<pair<int, int>> paths;
void dfs(vector<vector<int>>& matrix, int i, int j, int n, int m, vector<pair<int, int>>& res) {
	res.push_back(make_pair(i, j));//æ’å…¥è·¯å¾„
	matrix[i][j] = 1;//èµ°è¿‡äº†å°±ä¸èƒ½å†èµ°äº†
	//é€’å½’ç»ˆæ­¢æ¡ä»¶
	if (i == n - 1 && j == m - 1) {
		paths = res;
		return;
	}
	//å››ä¸ªæ–¹å‘ ä¸Š[i-1][j]ä¸‹[i+1][j]å·¦[i][j-1]å³[i][j+1]
	if (i - 1 >= 0 && matrix[i - 1][j] == 0)
		dfs(matrix, i - 1, j, n, m, res);
	if (i + 1 < n && matrix[i + 1][j] == 0)
		dfs(matrix, i + 1, j, n, m, res);
	if (j - 1 >= 0 && matrix[i][j-1] == 0)
		dfs(matrix, i, j-1, n, m, res);
	if (j+1 < m && matrix[i][j+1] == 0)
		dfs(matrix, i , j+1, n, m, res);
	//å›æº¯
	res.pop_back();
	matrix[i][j] = 0;
}


int main() {
	int n, m;
	while (cin >> n >> m) {
		vector<vector<int>> matrix(n, vector<int>(m,0));
		vector<pair<int, int>> res;
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < m; j++) {
				cin >> matrix[i][j];
			}
		}
		dfs(matrix, 0, 0, n, m, res);
		for (auto i : paths) {
			cout << "(" << i.first << "," << i.second << ")" << endl;
		}
	
	}
}

```

### å¹¿åº¦ä¼˜å…ˆç®—æ³•BFS
### æœç´¢å›æº¯
### åŠ¨æ€è§„åˆ’(å¯ç§»æ­¥åŠ¨æ€è§„åˆ’.md)


# å…¶å®ƒ

1. `#include<algorithm>`ä¸­å–å®¹å™¨çš„æœ€å¤§å€¼å’Œæœ€å°å€¼æ–¹æ³•
	- max_element(first,end,cmp)
	- min_element(first,end,cmp)

	> è¿”å›å®¹å™¨ä¸­æœ€å°å€¼å’Œæœ€å¤§å€¼çš„æŒ‡é’ˆã€‚å…¶ä¸­cmpä¸ºå¯é€‰æ‹©å‚æ•°, cmpå¯ä»¥æ˜¯è‡ªå®šä¹‰çš„å‡½æ•°!
	```
	#include<iostream>
	#include<map>
	#include <algorithm>
	using namespace std;

	//å®šä¹‰cmpå‡½æ•°
	bool cmp_value(const pair<int, int> left, const pair<int, int> right)
	{
		return left.second < right.second;
	}

	int main()
	{
		map<int, int> test;
		//åˆå§‹åŒ–
		test.emplace(10, 5);//æ’å…¥
		test.emplace(3, 17);
		test.emplace(19, 20);
		test.emplace(20, 20);
		//è¾“å‡ºæŒ‰åºæ’åˆ—çš„keyå€¼ mapåŸå› 
		for (auto it : test)
			cout << it.first << " ";
		cout << endl;
		//iæ˜¯è¿­ä»£å™¨  è¿”å›å€¼ä¸º19-20 ä½†åªèƒ½è¿”å›ä¸€ä¸ªè¿­ä»£å™¨
		auto i = max_element(test.begin(), test.end(), cmp_value);
		cout << i->first <<" " << i->second << endl;
		return 0;
	}

	output:
	19 20
	```


2. æ¬§æ‹‰è´¨æ•°ç­›
```
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
//ç´ æ•°åˆ¤å®š åªéœ€è¦åˆ°sqrt(m)å³å¯
bool isPrime(int m) {
	if (m <= 1) return false;
	for (int i = 2; i < sqrt(m); i++) {
		if (m % i == 0) return false;
	}
	return true;

}

//å»ºç«‹Né•¿è´¨æ•°checkè¡¨ æ¬§æ‹‰çº¿æ€§è´¨æ•°ç­›
void buildPrimeTable(int N, bool* isprime_t, int *prime_t,int &count) {
	int cnt=0;
	isprime_t[0] = isprime_t[1] = false;
	for (int i = 2; i < N; i++) {
		if (isprime_t[i]) prime_t[cnt++] = i;//å¦‚æœæ˜¯è´¨æ•°å°±åŠ å…¥åˆ°è´¨æ•°è¡¨ä¸­ï¼Œç”¨æœ€å°çš„è´¨æ•°çš„iå€æå‰æ ‡è®°äº†åé¢çš„è´¨æ•°
		for (int j = 0; j< N; j++) {
			if (i * prime_t[j] >= N) break;
			isprime_t[i * prime_t[j]] = false;//æ¯ä¸€ä¸ªç´ æ•°éƒ½å°†å…¶å½“å‰çš„iå€æ•°æ ‡è®°ä¸ºéç´ æ•°
			if (i % prime_t[j] == 0) break;//æœ€å…³é”®åªæ ‡è®°ä¸€æ¬¡ï¼Œä¸ä¼šé‡å¤æ ‡jè®°ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯ç´ æ•°çš„å€æ•°
		}
		
	}
	count = cnt;
}

int main() {

	const int len = 100;
	bool isprime_t[len]; //å¦‚æœå€¼ä¸º0ï¼Œå°±æ˜¯è´¨æ•° 01ä¸æ˜¯è´¨æ•°ç›´æ¥æ ‡è®°
	memset(isprime_t, true, sizeof(isprime_t));
	int prime_t[len];
	int count;
	buildPrimeTable(len, isprime_t, prime_t, count);
	for (int i = 0; i < count; i++) {
		cout << prime_t[i] << " ";
	}
	cout <<endl<< count << endl;
	for (int i = 0; i < len; i++) {
		cout << isprime_t[i] << " ";
	}
	return 0;
}
```